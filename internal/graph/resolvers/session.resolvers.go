package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"gqlgen-starter/internal/app/models"
	"gqlgen-starter/internal/ent"
	"gqlgen-starter/internal/ent/user"
	"gqlgen-starter/internal/graph/generated"
	"gqlgen-starter/internal/graph/model"
	"gqlgen-starter/internal/oops"
	"net/http"

	"golang.org/x/crypto/bcrypt"
)

// CreateSession is the resolver for the createSession field.
func (r *mutationResolver) CreateSession(ctx context.Context, input model.CreateSessionInput) (*models.Session, error) {
	entC := ent.FromContext(ctx)
	u, err := entC.User.Query().
		Where(user.Email(input.Email)).
		Only(ctx)
	if err != nil {
		return nil, &oops.CodedError{
			HumanMessage: "Invalid credentials",
			Context:      fmt.Sprintf("querying for User %s to create session", input.Email),
			HttpStatus:   http.StatusInternalServerError,
			Err:          err,
		}
	}
	if err = bcrypt.CompareHashAndPassword(u.HashedPassword, []byte(input.Password)); err != nil {
		return nil, &oops.CodedError{
			HumanMessage: "Invalid credentials",
			Context:      fmt.Sprintf("comparing hash of password"),
			HttpStatus:   http.StatusInternalServerError,
			Err:          err,
		}
	}

	err = r.AppContext.SessionManager.RenewToken(ctx)

	if err != nil {
		return nil, &oops.CodedError{
			HumanMessage: "Error creating session",
			Context:      fmt.Sprintf("renewing session token for %s", input.Email),
			HttpStatus:   http.StatusInternalServerError,
			Err:          err,
		}
	}

	r.AppContext.SessionManager.Put(ctx, ent.ContextViewerKey.Name, u)

	return &models.Session{
		Token:  r.AppContext.SessionManager.Token(ctx),
		Expiry: r.AppContext.SessionManager.Deadline(ctx),
	}, nil
}

// DeleteSession is the resolver for the deleteSession field.
func (r *mutationResolver) DeleteSession(ctx context.Context) (bool, error) {
	v, err := ent.GetContextViewer(ctx)
	if err != nil {
		return false, err
	}
	u, _ := v.GetUser()

	if err := r.SessionManager.Destroy(ctx); err != nil {
		return false, &oops.CodedError{
			HumanMessage: "Error signing out of session",
			Context:      fmt.Sprintf("deleting session with SessionManager for %s", u.Email),
			HttpStatus:   http.StatusInternalServerError,
			Err:          err,
		}
	}

	return true, nil
}

// Viewer is the resolver for the viewer field.
func (r *queryResolver) Viewer(ctx context.Context) (*ent.Viewer, error) {
	if v := ctx.Value(ent.ContextViewerKey); v != nil {
		return v.(*ent.Viewer), nil
	}
	return nil, nil
}

// User is the resolver for the user field.
func (r *viewerResolver) User(ctx context.Context, obj *ent.Viewer) (*ent.User, error) {
	usr, ok := obj.GetUser()
	if ok {
		return usr, nil
	}
	return nil, nil
}

// Viewer returns generated.ViewerResolver implementation.
func (r *Resolver) Viewer() generated.ViewerResolver { return &viewerResolver{r} }

type viewerResolver struct{ *Resolver }
